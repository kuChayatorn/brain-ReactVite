/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 public/brain.gltf 
*/

import React, { useEffect, useMemo, useRef, useState } from 'react'
import { useGLTF, useScroll } from '@react-three/drei'
import { useFrame } from '@react-three/fiber';
import { easing } from 'maath'
import * as THREE from 'three'
import Carousel from './Carousel';
import { Arrow } from './Arrow';

const Model = ({ ...props }) => {
  const { nodes, materials } = useGLTF('/brain.gltf')
  const scroll = useScroll();
  const [scrollOffset, setScrollOffset] = useState(0);
  const meshRef = useRef();
  const [rotateOffset, setRotateOffset] = useState(0);
  const [cardIndex, setCardIndex] = useState(0);
  const [hoveredItem, setHoveredItem] = useState(null);

  const mesh1 = useRef();
  const mesh2 = useRef();
  const mesh3 = useRef();
  const mesh4 = useRef();

  const [hoveredModel1, setHoveredModel1] = useState(null);
  const [hoveredModel2, setHoveredModel2] = useState(null);
  const [hoveredModel3, setHoveredModel3] = useState(null);
  const [hoveredModel4, setHoveredModel4] = useState(null);





  useFrame((state, delta) => {
    setScrollOffset(scroll.offset >= 0 ? scroll.offset % 1 : (1 + scroll.offset) % 1)
    const targetRotation = new THREE.Vector3(0, rotateOffset, 0);
    easing.damp3(meshRef.current.rotation, targetRotation, 0.1, delta);

    // const t = 3.586+ 0.2 + 0.2 * Math.sin(state.clock.getElapsedTime() * 5);
    // meshRef.current && easing.damp3(mesh1.current.scale, hoveredModel1 ? t : 3.586, 0.3, delta);
    // meshRef.current && easing.damp3(mesh2.current.scale, hoveredModel2 ? t : 3.586, 0.3, delta);
    // meshRef.current && easing.damp3(mesh3.current.scale, hoveredModel3 ? t : 3.586, 0.3, delta);
    // meshRef.current && easing.damp3(mesh4.current.scale, hoveredModel4 ? t : 3.586, 0.3, delta);
  });

  const handlePointerClick = (index, e) => {
    e.stopPropagation()

    if (hoveredItem?.material) {
      hoveredItem.material = materials.BRAIN_TEXTURE_blinn2;
    }

    if (e?.object?.material && e.object.material.color) {
      const material = e.object.material.clone();
      material.color.set("#ff0000");
      e.object.material = material;
    }

    setHoveredItem(e.object);
    setCardIndex(Math.floor(index));
  };

  return useMemo(() => {
    return (
      <group>
      <group
        {...props}
        rotation-y={scrollOffset * (2 * Math.PI)}
      >
        <group
          ref={meshRef}>
          <mesh
            ref={mesh1}
            onPointerDown={(e) => (handlePointerClick(0, e))}
            // onPointerOver={(e) => (e.stopPropagation(),setHoveredModel1(true))}
            // onPointerOut={() => setHoveredModel1(false)}
            geometry={nodes.Brain_Part_02.geometry}
            material={materials.BRAIN_TEXTURE_blinn2}
            position={[-0.793, 0.552, -0.096]}
            rotation={[1.584, 0, 0]}
            scale={3.586} />
          <mesh
            ref={mesh2}
            onPointerDown={(e) => (handlePointerClick(1, e))}
            // onPointerOver={(e) => (e.stopPropagation(),setHoveredModel2(true))}
            // onPointerOut={() => setHoveredModel2(false)}
            geometry={nodes.Brain_Part_04.geometry}
            material={materials.BRAIN_TEXTURE_blinn2}
            position={[0.046, 1.873, 0.748]}
            rotation={[1.584, 0, 0]}
            scale={3.586} />
          <mesh
            ref={mesh3}
            onPointerDown={(e) => (handlePointerClick(2, e))}
            // onPointerOver={(e) => (e.stopPropagation(),setHoveredModel3(true))}
            // onPointerOut={() => setHoveredModel3(false)}
            geometry={nodes.Brain_Part_05.geometry}
            material={materials.BRAIN_TEXTURE_blinn2}
            position={[-0.768, 1.283, 0.889]}
            rotation={[1.584, 0, 0]}
            scale={3.586} />
          <mesh
            ref={mesh4}
            onPointerDown={(e) => (handlePointerClick(3, e))}
            // onPointerOver={(e) => (e.stopPropagation(),setHoveredModel4(true))}
            // onPointerOut={() => setHoveredModel4(false)}
            geometry={nodes.Brain_Part_06.geometry}
            material={materials.BRAIN_TEXTURE_blinn2}
            position={[-1.492, 1.873, 0.748]}
            rotation={[1.584, 0, 0]}
            scale={3.586} />
        </group>
      </group>
      <Arrow
        position={[4.6, 2, -0.096]}
        scale={0.5}
        onClick={() => { setRotateOffset(meshRef.current.rotation.y + Math.PI * 0.25) }}
      />
      <Arrow
        position={[-4.5, 2, -0.096]}
        scale={0.5} rotation={[0, 0, Math.PI]}
        onClick={() => { setRotateOffset(meshRef.current.rotation.y - Math.PI * 0.25) }}
      />
      <Carousel curCardIndex={cardIndex} />

    </group>
    );
  });


  
}

useGLTF.preload('/brain.gltf')

export default Model
