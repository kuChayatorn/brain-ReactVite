/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.4.1 public/brain.gltf 
*/

import React, { useEffect, useRef, useState } from 'react'
import { useGLTF, useScroll } from '@react-three/drei'
import { useFrame } from '@react-three/fiber';
import { easing } from 'maath'
import * as THREE from 'three'
import Carousel from './Carousel';
import { Arrow } from './Arrow';

const Model = ({ ...props }) => {
  const { nodes, materials } = useGLTF('/brain.gltf')
  const scroll = useScroll();
  const [scrollOffset, setScrollOffset] = useState(0);
  const meshRef = useRef();
  const arrowLeft = useRef();
  const arrowRight = useRef();
  const [rotateOffset, setRotateOffset] = useState(0);
  const [isDragging, setIsDragging] = useState(false);
  const [lastMousePosition, setLastMousePosition] = useState([0, 0]);
  const [cardIndex, setCardIndex] = useState(0);
  const [hoveredItem, setHoveredItem] = useState(null);
  const [hoveredArrowLeft, setHoveredArrowLeft] = useState(false);
  const [hoveredArrowRight, setHoveredArrowRight] = useState(false);

  useFrame((state, delta) => {
    setScrollOffset(scroll.offset >= 0 ? scroll.offset % 1 : (1 + scroll.offset) % 1)
    const targetRotation = new THREE.Vector3(0, rotateOffset, 0);
    easing.damp3(meshRef.current.rotation, targetRotation, 0.1, delta);
    console.log(arrowLeft.current)
    arrowLeft.current && easing.damp3(arrowLeft.current.scale, hoveredArrowLeft ? 1.15 : 1, 0.1, delta);
    arrowRight.current && easing.damp3(arrowRight.current.scale, hoveredArrowRight ? 1.15 : 1, 0.1, delta);
  });

  const handlePointerClick = (index, e) => {
    e.stopPropagation()

    if (hoveredItem?.material) {
      hoveredItem.material = materials.BRAIN_TEXTURE_blinn2;
    }

    if (e?.object?.material && e.object.material.color) {
      const material = e.object.material.clone();
      material.color.set("#ff0000");
      e.object.material = material;
    }

    setHoveredItem(e.object);
    setCardIndex(Math.floor(index));
  };

  const onPointerDown = (event) => {
    setIsDragging(true);
    setLastMousePosition([event.clientX, event.clientY]);
  };

  const onPointerMove = (event) => {
    if (isDragging) {
      event.stopPropagation()
      const [lastX, lastY] = lastMousePosition;
      const deltaX = event.clientX - lastX;
      meshRef.current.rotation.y += deltaX * 0.005;
      setLastMousePosition([event.clientX, event.clientY]);
    }
  };

  const onPointerUp = () => {
    setIsDragging(false);
  };


  return (
    <group>
      <group
        {...props}
        rotation-y={scrollOffset * (2 * Math.PI)}
      >
        <group
          ref={meshRef}>
          <mesh
            onPointerDown={(e) => (handlePointerClick(0, e))}
            geometry={nodes.Brain_Part_02.geometry}
            material={materials.BRAIN_TEXTURE_blinn2}
            position={[-0.793, 0.552, -0.096]}
            rotation={[1.584, 0, 0]}
            scale={3.586} />
          <mesh
            onPointerDown={(e) => (handlePointerClick(1, e))}
            geometry={nodes.Brain_Part_04.geometry}
            material={materials.BRAIN_TEXTURE_blinn2}
            position={[0.046, 1.873, 0.748]}
            rotation={[1.584, 0, 0]}
            scale={3.586} />
          <mesh
            onPointerDown={(e) => (handlePointerClick(2, e))}
            geometry={nodes.Brain_Part_05.geometry}
            material={materials.BRAIN_TEXTURE_blinn2}
            position={[-0.768, 1.283, 0.889]}
            rotation={[1.584, 0, 0]}
            scale={3.586} />
          <mesh
            onPointerDown={(e) => (handlePointerClick(3, e))}
            geometry={nodes.Brain_Part_06.geometry}
            material={materials.BRAIN_TEXTURE_blinn2}
            position={[-1.492, 1.873, 0.748]}
            rotation={[1.584, 0, 0]}
            scale={3.586} />
        </group>
      </group>
      <Arrow
        meshRef={arrowRight}
        position={[4.6, 2, -0.096]}
        scale={0.5}
        onClick={() => { setRotateOffset(meshRef.current.rotation.y + Math.PI * 0.25) }}
        onPointerEnter={() => setHoveredArrowRight(true)}
      />
      <Arrow
        meshRef={arrowLeft}
        position={[-4.5, 2, -0.096]}
        scale={0.5} rotation={[0, 0, Math.PI]}
        onClick={() => { setRotateOffset(meshRef.current.rotation.y - Math.PI * 0.25) }}
        onPointerEnter={() => setHoveredArrowLeft(true)}
      />
      <Carousel curCardIndex={cardIndex} />

    </group>

  )
}

useGLTF.preload('/brain.gltf')

export default Model
